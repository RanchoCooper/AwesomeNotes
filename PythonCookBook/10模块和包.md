---
title: 模块和包
date: 2016-11-25 10:45
category:
tags:
---

## 包结构
目录中含有`__init__.py`文件, Python解释器就会将其视作一个包.
从包中导入任何模块时, `__init__.py`都会被最先导入, 并形成相应包的命名空间

你可以这么理解, 面对多模块场景, 包结构为其提供了很好的管理机制(命名空间)以及自动加载(通         过`__init__.py`导入子模块),

另外, 通过`__all__`可以显式定义外部可见的名称不然, 形如 `from module import *`这样的导入操作会把全部不以下划线开头的符号全部导出

## 相对导入

- 位于顶层目录的模块不能使用相对导入
- 直接执行的模块其相对导入会失败(应该以-m 选项以模块方式加载)

更多导入机制可以参考[官方文档 - PEP0328](../Python官方文档/PEP328-导入.md)

## 模块分解
保持大模块逻辑结构完整的前提下将其拆解成多个子模块, 并通过`__init__.py`来将它们绑定在一起

如果对非常庞大的模块, 你希望在实际需要的时候才做实际的加载工作, 这时你需要作`惰性导入`

```python
# __init__.py
def A():
    from .a import A
    return A()

def B():
    from .b import B
    return B()
```

但这么做会有副作用: 一定程度上破坏了继承和类型检查机制

## 命名空间包
不带`__init__.py`的"包"就是一个命名空间包, 它仅仅为其中的模块提供了一层命名空间

这在开发第三方插件和框架扩展时很有用

区别包和命名空间包的方法: 查看`__file__`属性即可

## 重新加载
    import imp
    imp.reload(module)

reload()操作会擦除模块中的`__dict__`字典, 然后重新执行模块的源代码来刷新它. 但模块本身的标识信息并没有改变(比如id()查询). 但对于`from module import name`导入的符号来说, 是不会更新的, 并且会有两份定义(可以理解为`from..import`导入的符号会被添加到全局的命名空间, 而不是模块的命名空间)

    old = name
    new = module.name

## 目录可运行
为目录或zip文件添加一个`__main__.py`, 就可以在顶层目录中运行解释器

## 读取包数据
普通的IO操作在处理包数据的不足:
- 不能控制解释器的工作目录
- 包可能为.zip或.zgg文件

    import pkgutil
    data = pkgutil.get_data(_package, 'somedat.dat')

@hang: #10.10-P420
