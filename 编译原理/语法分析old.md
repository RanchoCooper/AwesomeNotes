---
title: 语法分析_old
date: 2016-06-14 09:22:48
categories: 编译原理
tags:
- Program

---

前端输入的源程序经过词法分析之后便得到了编译器可以识别的记号流, (好比是对代码字符流做了断句)那么编译器又是如何理解这些记号的呢? 这便是语法分析的工作

## 语法分析的任务
记号流(输入): 词法分析后得到的中间代码
语法规则(隐性输入): 语法判别的依据
语法树(输出):

分析代码的合法性
提示代码的语法错误 (如何优化提示?)
生成抽象语法树

$语法树如何体现缩进层次?

### 包含内容
- 数学理论: 上下文无关文法 CFG(描述语言语法规则的工具)
- 自顶向下分析: 递归下降分析算法(预测分析算法), LL分析算法
- 自底向上分析: LR分析算法

**语法分析就是完成从记号流到语法树的转换**



## 乔姆斯基文法体系
文法体系是为研究自然语言构造的一系列数学工具
3型(正则)文法: 描述程序语言的词法
2型(上下文无关)文法: 描述程序语言的语法
1型(上下文有关)文法
0型(任意)文法

### 形式化
例子:
{ S }
{ N: sheep, tigger, grass, water }
{ V: eat, drink }

S -> N V V (语句 -> 名词 动词 名词)
N -> s | t | g | w... (具体化的名词符号)
V -> e | d (具体化的动词)

开始符号: S
非终结符: { 所有的大写字母(语句, 名词, 动词) }
终结符: { 所有的小写字母(具体的名词或动词符号) }

## 上下文无关文法
### 定义
文法 G 是一个四元组: G = (T, N, P, S)
其中,
T是终结符集合,
N是非终结符集合,
P是一组产生式规则(由语言语法定义给出)
    - 每条规则的形式: x -> β1, β2... βn <br/>
    其中 x∈N, β∈(T∪N)

S是唯一的开始符号(非终结符) S ∈ N

### 推导
给定文法G, 从G的开始符号S开始, 用产生式右侧部分迭代地替换左侧的非终结符, 直到不出现非终结符为止, 最终得到的串称为句子

#### 最左(右)推导
每次总是选择最左(右)侧的非终结符 进行替换

#### 语法分析
检查句子s是否可以由文法G和产生式规则P生成
回到前面`语法分析期的任务`
实际上就是给定了句子S和语法规则G, S是否能从G推导得出(判断正确性)

#### 特殊化: 正则文法
当上下文无关文法的产生式限定在如下三种形式之一
A -> b C
X -> b
Y ->
便得到了三型(正则)文法

## 分析树与二义性
推导过程中的每一步是分析树上的一个边界, 而最终得到的结果则是分析树的叶子

### 分析树
- 推导可以表达成树状结构
    - 和推导所用的顺序无关(最左, 最右, 其他)
- 树种的每个内部节点代表非终结符
- 每个叶子节点代表终结符
- 每一步推导代表如何从双亲节点生成它的直接孩子节点

`分析树的含义取决于树的后序遍历`

### 二义性文法
给定文法G, 如果存在句子S, 它有两棵不同的分析树, 则称G是二义性文法
从编译器角度, 二义性文法存在问题:
- 同一个程序有不同的含义
- 因此程序运行的结果不是唯一的

解决方案: 文法的重写

## 语法分析器的实现
语法分析器: 对给定的文法G和句子s, 判断S是否可以从G推导出来(输入的记号流是否符合该编程语言的语法规则)

#### 算法思想
从G的开始符号出发, 随意推导出某个句子t, 比较t和s
若 t == s, true
否则, 回溯
(对应与分析树的自顶向下的构造顺序)


### 自顶向下的回溯

### 算法讨论
- 回溯引起的效率问题
编译器必须高效, 需要线性的算法(递归下降和LL(1)分析算法)

`那么问题来了报错提示到底哪家强?`
`gcc, clang, vc++, jvm....`

## 递归下降分析(属于自顶向下)

也称为预测分析
- 分析高效(线性时间)
- 容易实现(方便手工编码)
- 错误定位和诊断信息准确 (GCC4.0, LLVM)

算法基本思想
- 每个非终结符构造一个分析函数k
- 用前看符号指导产生式规则的选择

### 一般的算法框架
```
parse_X()
    token = nextToken()
    switch(token)
        case ...: // 前看符号判等
        case ...: //
        case ...: //
        ...
        default: ...
```

## LL(1)分析算法(属于自顶向下)
从左(L)向右读入程序, 最左(L)推导, 采用一个(1)前看符号

-  分析高效(线性时间)
- 错误定位和诊断信息准确
- 众多开源或商业生成工具

## 算法基本思想
表驱动的分析算法
